整理自《深入理解Java虚拟机》

![深入理解Java虚拟机(汇总).jpg](https://github.com/bluesnail95/document/blob/master/img/jvm/深入理解Java虚拟机(汇总).jpg)

## 一:运行时数据区域

Java虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域。

### 1 . 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

### 2 . Java虚拟机栈

虚拟机栈描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和retureAddress类型(指向了一条字节码指令的地址)。

可能出现的两种异常:

(1).如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；

(2)如果虚拟机栈拓展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 3 . 本地方法栈

本地方法栈与虚拟机栈的作用相似，不同的是虚拟机栈执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用的Native方法服务。

与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

### 4 . Java堆

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

### 5 . 方法区

方法区和Java堆一样，是各个线程共享的内存区域，它利用存储已被虚拟机加载的类信息，常量、静态变量、即时编译器编译后的代码等数据。

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

### 6 . 运行时常量池

运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。

## 二:内存溢出异常

### 1 . 堆溢出

-XX:+HeapDumpOnOutOfMemoryError：让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。

要解决这个区域的异常：一般的手段是先通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是先分清楚到底是出现内存泄漏还是内存溢出。

### 2 . 虚拟机栈和本地方法栈溢出

(1)如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

(2)如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### 3 . 方法区和常量池溢出

String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。

### 4 . 本机直接内存溢出

DirectMemory容量可以通过-XX: MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值(-Xmx指定）一样。

## 三:垃圾收集

### 1.可达性分析算法:

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象不可用。

### 2.可作为GC Roots的对象包括以下几种：
(1)虚拟机栈(栈帧中的本地变量表)中引用的对象。
(2)方法区中类静态属性引用的对象。
(3)方法区中常量引用的对象。
(4)本地方法栈中JNI(即一般说的Native方法)引用的对象。

### 3.引用

如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。

(1)强引用

类似“Object obj = new Object()"。垃圾收集器不会回收被强引用的对象。

(2)软引用

在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。

(3)弱引用

被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

(4)虚引用

最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。

### 4.判断是否存活

(1)第一次标记

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finialize()方法。当对象没有覆盖finialize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为“没必要执行”。

(2)第二次标记

a.对象可以在finialize()方法中重新与引用链上的任何一个对象建立连接就可以被移出"即将回收"的集合。

b.一个对象的finalize()方法最多被系统调用一次。

### 5.回收方法区

主要回收：

(1)废弃的常量

(2)无用的类

### 6:无用的类的判定：

(1)该类所有的实例已经被回收，也就是Java堆中不存在该类的任何实例。

(2)加载该类的ClassLoader已经被回收。

(3)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 四:垃圾收集算法

### 1.标记-清除算法

标记：标记出所有需要回收的对象。

清除：统一回收所有被标记的对象。

缺点：

(1)在标记和清除的过程，效率都不高。

(2)标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致在分配较大对象时，无法找到足够大的连续空间而提前触发一次垃圾收集。

### 2.标记-整理算法

让所有存活的对象往一端移动，然后清理掉边界以外的内存。

### 3.复制算法

将可用内存按容量分成两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另一块上，然后再把已使用过的内存空间一次清理掉。

### 4.分代收集算法

根据对象存活周期的不同将内存划分为几块：

(1)在新生代中，每次都有大批对象死去，只有少量存活，选用复制算法。

(2)老年代的对象存活率高，没有额外空间对它进行分配担保，使用“标记-整理”和“标记-清理”算法进行回收。

## 五:垃圾收集器

### 1 . 新生代

#### 1.1 Serial收集器

(1)单线程收集器：只使用一个CPU或一条收集线程去完成垃圾收集工作。在进行垃圾收集时，需要暂停其他所有的工作线程。

(2)简单高效，对于限定单个CPU环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率。

#### 1.2 ParNew收集器

(1)Serial收集器的多线程版本。

(2)目前，新生代只有Serial和ParNew能和老年代的CMS收集器配合工作。

#### 1.3 Parallel Scavenge收集器

(1)使用复制算法，并行的多线程收集器。

(2)达到一个可控制的吞吐量。吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间）。

(3)停顿时间短适合与用户交互的程序，良好的响应速度可以提升用户体验。高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

(4)-XX:MaxGCPauseMillis(控制最大垃圾收集停顿时间)。

-XX:GCTimeRatio(直接设置吞吐量大小)。

-XX:+UserAdaptiveSizePolicy(GC自适应的调节策略)。

### 2 . 老年代

#### 2.1 Serial Old收集器

(1)Serial收集器的老年代版本。

(2)使用“标记-整理”算法。

#### 2.2 Parallel Old收集器

(1)Parallel Scavenge收集器的老年代版本。

(2)在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old收集器。

#### 2.3 CMS 收集器

(1)是一种以获取最短回收停顿时间为目标的收集器。

(2)基于“标记-清除”算法实现，整个过程分为4个步骤：

a.初始标记：标记一下GC Roots能直接关联的对象，速度很快。

b.并发标记：进行GC Roots Tracing的过程。

c.重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。

d.并发清除。

初始标记和重新标记都需要“stop the world"，而并发标记和并发清除可以与用户线程一起执行。

(3)缺点：

a.CMS收集器对CPU资源非常敏感，需要拿出一部分CPU资源进行垃圾收集，用户程序的执行就会变慢。

b.CMS收集器无法处理浮动垃圾(并发清除阶段会产生新的垃圾，但是没办法在这一阶段进行回收)，可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。

c.收集结束时会有大量空间碎片产生(CMS使用的垃圾收集算法是标记-清除)。

-XX:+UseCMSCompactAtFullCollection开关参数(默认就是开启的)，用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。

#### 2.4. G1收集器

(1)G1是一款面向服务端应用的垃圾收集器。

(2)G1具有以下特点：

a.并行与并发：缩短Stop-The-World停顿的时间。

b.分代收集:跟其他垃圾收集器一样保留了老年代和新生代的概念，不同的是G1将堆内存划分为多个大小相等的region，新生代和老年代不是物理隔离的，也不必是连续的。

c.空间整合：从整体看是基于“标记-整理”算法实现的收集器，从局部上看是基于“复制算法“实现的收集器，G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。

d.可预测的停顿：能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

(3)G1收集器的运作可以划分为以下几个步骤：

a.初始标记：标记GC Roots能直接关联到的对象，并且修改Next Top at Mark Start的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这一阶段需要停顿线程，耗时短。

b.并发标记：从GC Roots开始对堆中的对象进行可达性分析，找出存活的对象，耗时长，但可与用户线程并发执行。

c.最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行。

d.筛选回收：在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

(4)G1收集器的Java堆的内存布局

a.将Java堆分成多个大小相等的独立区域(Region)。

b.有计划的避免在整个Java堆进行全区域的垃圾收集。

c.使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

d.Region不可能是孤立的，一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。

e.在G!收集器中，Region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，虚拟机都是通过Remembered Set来避免全堆扫描。

3.Minor GC和Full GC的区别

新生代GC(Minor GC)：指发生在新生代的垃圾收集动作。

老年代GC(Major GC/Full GC)：指发生在老年代的垃圾收集动作。

## 六.JDK命令行工具

### 1 . jps

JVM Process Status Tool：显示指定系统内所有Hotspot虚拟机进程。

### 2 . jstat

JVM Statistics Monitoring Tool：用于收集HotSpot虚拟机各方面运行数据

### 3 . jinfo

Configuration Info for Java:显示虚拟机的配置信息。

### 4 . jmap

jmap；Memory Map for Java,生成虚拟机的内存转储快照(heapdump文件）。

### 5 . jhat

JVM Heap Dump Browser：用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果。

### 6 . jstack

Stack Trace for Java,显示虚拟机的线程快照。

### 7 . HSDIS

## 七.加载机制

### 1.什么是类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

(1)Java语言的类型的加载、连接和初始化都是在程序运行期间完成的。

(2)Java的动态拓展的语言特性依赖运行期动态加载和动态连接实现。

### 2.类加载的周期

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个阶段统称为连接。

#### 2.1加载

在加载阶段，虚拟机需要完成以下3件事情：

(1)通过一个类的全限定名来获取定义此类的二进制字节流。

(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

(3)在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段既可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成。数组本身不通过类加载器创建，而是由虚拟机直接创建。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。

#### 2.2验证

验证是连接阶段的第一步，这一阶段的主要目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段需要完成以下四个阶段的校验动作：

(1)文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上描述一个Java类型信息的要求。

(2)元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。

(3)字节码验证：目的是通过数据流和控制流分析，确保程序语义是合法，符合逻辑的。

(4)符号引用：可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。符号引用校验的目的是确保解析动作能正常执行，如果无法通过符合引用验证，那么将抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。

#### 2.3准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随对象一起分配在Java堆中。

#### 2.4解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用：符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

#### 2.5初始化

2.5.1.主动引用(立即对类进行初始化)：

(1)遇到到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。

场景：

a.使用new关键字实例化对象时

b.读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外）

c.调用一个类的静态方法。

(2)使用java.lang.reflect包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。

(3)当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

(4)当虚拟机启动时，用户需要指定一个要执行的主类(包括main()方法的那个类)，虚拟机会先初始化这个主类。

2.5.2.被动引用(引用类不会触发初始化)：

(1)对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不是触发子类的初始化。

2.5.3.类和接口初始化的区别：

当一个类被初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。

编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

## 八.类加载器

### 1.什么是类加载器？

把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类。实现这个动作的代码模块称为”类加载器“。

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。

比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类必定不相等。

### 2.加载器的分类

(1)启动类加载器：Bootstrap ClassLoad

(2)拓展类加载器：Extension ClassLoader

(3)应用程序类加载器：Application ClassLoader

### 3.双亲委派模型

3.1.双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父加载器的代码。

3.2.双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到这个所需的类）时，子加载器才会尝试自己去加载。

3.3.双亲委派模型的实现（java.lang.ClassLoader.loadClass()）:先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。	

3.4.优点

(1)Java类随着它的加载器一起具备了一种具有优先级的层级关系。

3.5.双亲委派模型的破坏

## 九.JDK可视化工具

### 1.JConsole

一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理。

### 2.VisualVM

## 十.HotSpot虚拟机对象

### 1 . 对象的创建

#### 1.1 类加载检查

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就必须先执行相应的类加载过程。

#### 1.2 为新生对象分配内存

为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

1.2.1 指针碰撞

假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就是把指针向空闲空间那边挪动一段与对象大小相等的距离。

1.2.2 空闲列表

如果Java堆中的内存不是规整的，那虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

### 2 . 对象的内存布局

#### 2.1 对象头

包括两部分信息：
(1)第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

(2)另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象类型上保留类型指针。

#### 2.2 实例数据

对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。

#### 2.3 对齐填充

不是一定要存在，起着占位符的作用。

### 3 . 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象。

#### 3.1 句柄

Java堆会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

优点：reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。

#### 3.2 直接指针

reference中存储的就是对象地址。

优点：速度更快，节省了一次指针定位的时间开销。

## 十一.内存管理

### 1.给对象分配内存

(1)按数据区分：在堆上分配，但是也可能经过JIT编译后被拆散为标量类型并间接在栈上分配。

(2)按年代分：对象主要分配在新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况也可能直接分配在老年代中。

(3)分配的规则取决于垃圾收集器的组合和虚拟机中与内存有关参数的设置。	

a. 对象优先在Eden区分配

当Eden区没有足够的空间时，将发生一次Minor GC。

b . 大对象直接进入老年代

大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串和数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

c . 长期存活的对象将进入老年代

对象被复制15次就会进入老年代，可以通过-XX:MaxTenuringThreshold设置这个次数。

d . 动态对象年龄判断

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

e. 空间分配担保

在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果成立，那minor gc就是安全的。

2.回收分配给对象的内存


## 十二.运行时栈帧结构

(1)栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。

(2)栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。

(3)每一个方法从调用开始到执行完成的过程都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。

(4)对于执行引擎来说，只有位于栈顶的栈帧才是有效的，称为当前栈帧。与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前帧栈进行操作。

栈帧结构包含以下：

### 1 . 局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽(slot)为最小单位，每个slot都能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。

reference类型表示一个对象实例的引用，虚拟机能通过这个引用做到：

(1)从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引。

(2)此引用中直接或是间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束。

### 2 . 操作栈

操作数栈常称为操作栈，是一个后入先出的栈。

Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。

### 3 . 动态连接

Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

### 4 . 方法返回地址

(1)正常完成出口：执行引擎遇到任意一个方法返回的字节码指令。

(2)异常完成出口：在方法执行过程遇到了异常，并且这个异常在方法体内没有得到处理。

### 5 . 附加信息

## 十三.方法调用

方法调用在Class文件中存储的都是符号引用。

### 1.解析

方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。

解析调用是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期去完成。

1.1 invokestatic：调用静态方法

1.2 invokespecial：调用实例构造器<init>方法、私有方法和父类方法。

1.3 invokevirtual：调用所有的虚方法

1.4 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。

1.5 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。该指令的分派逻辑是由用户所设定的引导方法决定的。

### 2 . 分派

#### 2.1 按动静分

(1)静态分派

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。

典型应用是方法重载。

(2)动态分派

在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。

典型应用是方法重写。

#### 2.2 按宗量数分

方法的接收者和方法的参数统称为方法的宗量。

(1)单分派

根据一个宗量对目标方法进行选择。

(2)多分派

根据多于一个宗量对目标方法进行选择。

### 3 . 动态类型语言支持

动态类型语言的关键是它的类型检查的主体是在运行期而不是编译期。

静态类型语言和动态类型语言的区别：

(1)编译器提供更严谨的类型检查，与类型相关的问题在编码的时候就能及时发现，利于稳定性及代码达到更大规模。

(2)动态类型语言在运行期确定类型，具有更大的灵活性。

## 十四.编译代码优化

### 1.早期(编译期)优化

Java的“编译期”有以下三种解释：

(1)指前端编译器把*.java文件转变成*.class文件的过程。

(2)指虚拟机的后端运行期编译器(JIT编译器)把字节码转变成机器码的过程。

(3)指使用静态提前编译器(AOT编译器)直接把*.java文件编译成本地机器码的过程。

### 2.晚期(运行期)优化
